指针（pointer）是一个通用概念，它指代那些包含内存地址的变量。

这个地址被用于索引，或者说用于“指向”内存中的其他数据。

智能指针（smart pointer）则是一些数据结构，它们的行为类似于指针但拥有额外的元数据和附加功能。

引用计数 （reference counting）智能指针类型。这种指针会通过记录所有者的数量来使一份数据被多个所有者同时持有，并在没有任何所有者时自动清理数据。

> 引用和智能指针之间还有另外一个差别：引用是只借用数据的指针；而与之相反地，大多数智能指针本身就拥有它们指向的数据。

如：String与Vec<T>

通常会使用结构体来实现智能指针，但区别于一般结构体的地方在于它们会实现Deref与Drop这两个trait。

常用的智能指针：

• Box<T>，可用于在堆上分配值。

• Rc<T>，允许多重所有权的引用计数类型。

• Ref<T>和RefMut<T>，可以通过RefCell<T>访问，是一种可以在运行时而不是编译时执行借用规则的类型。

## 使用Box<T>在堆上分配数据

装箱 （box）是最为简单直接的一种智能指针，它的类型被写作Box<T>。装箱使我们可以将数据存储在堆上，并在栈中保留一个指向堆数据的指针。

除了将它们的数据存储在堆上而不是栈上，装箱没有其他任何的性能开销。

装箱常常被用于下面的场景中：

• 当你拥有一个无法在编译时确定大小的类型，但又想要在一个要求固定尺寸的上下文环境中使用这个类型的值时。

• 当你需要传递大量数据的所有权，但又不希望产生大量数据的复制行为时。

• 当你希望拥有一个实现了指定trait的类型值，但又不关心具体的类型时。

转移大量数据的所有权可能会花费较多的时间，因为这些数据需要在栈上进行逐一复制。为了提高性能，可以借助装箱将这些数据存储到堆上。通过这种方式，只需要在转移所有权时复制指针本身即可，而不必复制它指向的全部堆数据。

## 使用Box<T>在堆上存储数据

使用装箱在堆上存储一个i32值

```rust
src/main.rs
fn main() {
    let b = Box::new(5);
    println!("b = {}", b);
}
```

装箱会在离开自己的作用域时（也就是b到达main函数的结尾时）被释放。

### 使用装箱定义递归类型

递归类型的值可以在自身中存储另一个相同类型的值，因为这种嵌套在理论上可以无穷无尽地进行下去，所以Rust根本无法计算出一个递归类型需要的具体空间大小。但是，装箱有一个固定的大小，我们只需要在递归类型的定义中使用装箱便可以创建递归类型了。

尝试使用枚举来表达一个持有i32值的链接列表数据类型

```rust
src/main.rs
enum List {
    Cons(i32, List),
    Nil,
}
```

使用List枚举存储列表1, 2, 3

```rust
// panic !!!
// panic !!!
// panic !!!
// Rust无法计算出存储一个List值需要消耗多大的空间
src/main.rs
use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1, Cons(2, Cons(3, Nil)));
}
```

#### 计算一个非递归类型的大小

```rust
enum Message {
    Quit,
    Move { x: i32, y: i32 },
    Write(String),
    ChangeColor(i32, i32, i32),
}
```

Rust会遍历枚举中的每一个成员来找到需要最大空间的那个变体。

在Rust眼中，Message::Quit不需要占用任何空间，Message::Move需要两个存储i32值的空间，以此类推。

因为在每个时间点只会有一个变体存在，所以Message值需要的空间大小也就是能够存储得下最大变体的空间大小。

> Cons变体需要的空间也就等于一个i32值的大小加上一个List值的大小。为了确定List值所需的空间大小，编译器又会从Cons开始遍历其下的所有变体，这样的检查过程将永无穷尽地进行下去。

#### 使用Box<T>将递归类型的大小固定下来

Box<T>是一个指针，所以Rust总是可以确定一个Box<T>的具体大小。

在Cons变体中存放一个Box<T>而不是直接存放另外一个List值。而Box<T>则会指向下一个List并存储在堆上，而不是直接存放在Cons变体中。

修改代码，通过编译
为了拥有固定大小而使用Box<T>的List定义

```rust
src/main.rs
enum List {
    Cons(i32, Box<List>),
    Nil,
}

use crate::List::{Cons, Nil};

fn main() {
    let list = Cons(1,
        Box::new(Cons(2,
            Box::new(Cons(3,
                Box::new(Nil))))));
}
```

> 任意的List值都只需要占用一个i32值加上一个装箱指针的大小。

## 通过Deref trait将智能指针视作常规引用

实现Deref trait使我们可以自定义解引用运算符 （dereference operator）*的行为（这一符号也同时被用作乘法运算符和通配符）。

### 使用解引用运算符跳转到指针指向的值

使用解引用运算符跟踪i32值的引用

```rust
src/main.rs
fn main() {
   let x = 5;
   let y = &x;

   assert_eq!(5, x);
   assert_eq!(5, *y);
}
```

### 把Box<T>当成引用来操作

src/main.rs
fn main() {
    let x = 5;
    let y = Box::new(x);

    assert_eq!(5, x);
    assert_eq!(5, *y);
}

### 定义我们自己的智能指针

```rust
use std::ops::Deref;

fn main() {
    let x = 5;
    let y = MyBox::new(x);

    assert_eq!(5, x);
    // *y会被Rust隐式地展开为：
    // *(y.deref())
    assert_eq!(5, *y);
}

// 拥有T类型单元素的元组结构体
struct MyBox<T>(T);

impl<T> MyBox<T> {
    fn new(x: T) -> MyBox<T> {
        MyBox(x)
    }
}

// 在没有Deref trait的情形下，
// 编译器只能对&形式的常规引用执行解引用操作。
impl<T> Deref for MyBox<T> {
    type Target = T;
    fn deref(&self) -> &T {
        &self.0
    }
}
```

### 函数和方法的隐式解引用转换

```rust
src/main.rs
fn hello(name: &str) {
    println!("Hello, {}!", name);
}

fn main() {
    let m = MyBox::new(String::from("Rust"));
    hello(&m);
}
```

&m是一个指向MyBox<String>值的引用，Rust通过调用deref来将&MyBox<String>转换为&String。标准库为String提供的Deref实现会返回字符串切片，继续调用deref来将&String转换为&str，并最终与hello函数的定义相匹配。

### 解引用转换与可变性

使用Deref trait能够重载不可变引用的*运算符。与之类似，使用DerefMut trait能够重载可变引用的*运算符。

如果存在一个可变引用，那么它就必须是唯一的引用（否则程序将无法通过编译）。将一个可变引用转换为不可变引用肯定不会破坏借用规则，但将一个不可变引用转换为可变引用则要求这个引用必须是唯一的，而借用规则无法保证这一点。

## 借助Drop trait在清理时运行代码

实现Drop trait来指定值离开作用域时需要运行的代码。

Drop trait引入作用域，因为它已经被包含在了预导入模块中
```rust
src/main.rs
struct CustomSmartPointer {
    data: String,
}

impl Drop for CustomSmartPointer {
    fn drop(&mut self) {
       println!("Dropping CustomSmartPointer with data `{}`!", self.data);
    }
}

fn main() {
   let c = CustomSmartPointer { data: String::from("my stuff") };
   let d = CustomSmartPointer { data: String::from("other stuff") };
   println!("CustomSmartPointers created.");
}

//CustomSmartPointers created.
//Dropping CustomSmartPointer with data `other stuff`!
//Dropping CustomSmartPointer with data `my stuff`!
```

变量的丢弃顺序与创建顺序相反

### 使用std::mem::drop提前丢弃值

Drop trait中的drop方法，不能直接显示调用，
在main函数结尾的地方会自动调用了drop，这种行为会试图对同一个值清理两次而导致重复释放（double free）错误。

```rust
// panic !!!
// panic !!!
// panic !!!
src/main.rs
fn main() {
    let c = CustomSmartPointer { data: String::from("some data") };
    println!("CustomSmartPointer created.");
    c.drop();
    println!("CustomSmartPointer dropped before the end of main.");
}
```

std::mem::drop函数， 手动调用这个函数
```rust
src/main.rs
fn main() {
    let c = CustomSmartPointer { data: String::from("some data") };
    println!("CustomSmartPointer created.");
    drop(c);
    println!("CustomSmartPointer dropped before the end of main.");
}
```